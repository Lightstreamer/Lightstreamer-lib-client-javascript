
import Executor from "../../src-tool/Executor";
import LoggerManager from "../../src-log/LoggerManager";
import Assertions from "../utils/Assertions";
import Constants from "../Constants";
import UpdateCopy from "./UpdateCopy";
   
  var subscriptionsLogger = LoggerManager.getLoggerProxy(Constants.SUBSCRIPTIONS);
  
  
  var SubscriptionsHandler = function(policyBean) {
      
    /*
     * NB 
     * TableIds are internal codes to identify subscriptions.
     * TableNums are the values of the parameters LS_table (i.e. subIds in TLCP jargon),
     * are generated by Masters and are communicated asynchronously to Slaves
     * (as SubscriptionsHandlers).
     */
    
    this.nextId = 0;
    /* Map from tableIds to Subscriptions */
    this.tableInfosFromId = {};
    /* Map from tableNums (i.e. subIds) to tableIds */
    this.tableIdsFromNum = {};
    this.generationNumber = 1;

    /* Map from tableIds to Promises */
    this.promisesFromId = {};
    /* Map from tableIds to integers (what does it mean?!) */
    this.promiseQueuesFromId = {};
    // invariant on each element:
    // the promise exists iff the promiseQueue exists;
    // after the startup, the promiseQueue is always > 0;
    // the promise is created before the corresponding element in tableIdsFromNum
    
    this.eh = null;
    this.policyBean = policyBean;
    
    this.controlRequestTimeout = 4000;

    /*
     * Current phase used to discard promises created in a session 
     * but resolved in a successive session. 
     * It is incremented when a session finishes, 
     * that is when pauseAllTables is called.
     */
    this.phase = 0;
  };
  
  SubscriptionsHandler.prototype = {
      
    /*public*/ toString: function() {
      return "[SubscriptionsHandler]";
    }, 
    
    /*public*/ setControlRequestTimeout: function(val) {
      this.controlRequestTimeout = val;
      //PushPage guarantees this value is valid
    },
    
    /*public*/ switchEngineHandler:function(engineHandler) {
      this.eh = engineHandler;
    },
      
    /*public*/ getAllTables: function() {
      return this.tableInfosFromId;
    },
    
    /*public*/ addATable: function(tableIn) {
      var _id = ++this.nextId;
      
      subscriptionsLogger.logInfo("Subscribing subscription",tableIn);
      
      tableIn.onAdd(_id,++this.generationNumber,this);
      this.tableInfosFromId[_id] = tableIn;

      this.passTableToEngine(tableIn);

    },
   
    /*public*/ removeATable: function(subscriptionOut) {

      if (this.eh && this.eh.isSessionAlive()) {
        var tNum = subscriptionOut.getTableNumber();
        if (subscriptionOut.isSubscribing() || subscriptionOut.isPushing()) {
          if (tNum) {
            //we possess already a tableNumber for this table
            this.eh.unsubscribeTable(tNum);

            delete(this.tableIdsFromNum[tNum]);
          } // else the promise receiving the tablenum will take care of it

        }

      }

      subscriptionsLogger.logInfo("Unsubscribing subscription",subscriptionOut);

      var _id = subscriptionOut.getSubscriptionId();
      subscriptionOut.onRemove();
      delete(this.tableInfosFromId[_id]);

      return subscriptionOut;
      
    },
    
    /*public*/ updateSubscriptionParams: function(subscriptionChanging,changingParams) {
      if (!this.eh || !this.eh.isSessionAlive() || !subscriptionChanging.isActive()) {
        //new session will trigger the subscription
        return;
      }



      //>>excludeStart("debugExclude", pragmas.debugExclude);
      Assertions.verifyOk(subscriptionChanging.isActive(), "Inactive subscription")
      //>>excludeEnd("debugExclude");

        //notify the engine
        var tableId = subscriptionChanging.getSubscriptionId();
        if (this.promisesFromId[tableId]) {
          subscriptionsLogger.logDebug("Enqueueing subscription update",subscriptionChanging);
          var that = this;
          this.enqueueToPromise(tableId, function(tableNumber) {
            subscriptionsLogger.logDebug("Resuming subscription update",subscriptionChanging);
            that.eh.updateSubscriptionParams(tableNumber,changingParams);
          })
        } else {
            // we must possess already a tableNumber for this table
            subscriptionsLogger.logDebug("Executing subscription update",subscriptionChanging);
            var tNum = subscriptionChanging.getTableNumber();
            this.eh.updateSubscriptionParams(tNum,changingParams);
        }

    },
    
    /*private*/ passTableToEngine: function(tableIn) {
      if (!this.eh || !this.eh.isSessionAlive()) {
        //new session will trigger the subscription
        return;
      }
      
      if (!tableIn.isPaused()) {
        //removed, pushing, or tableNum received... that's all
        return;
      }
      var tableId = tableIn.getSubscriptionId();

      subscriptionsLogger.logDebug("sending Subscription to the engine");

      var tableNumPromise = this.eh.subscribeTable(tableIn.getRequestParams());
      if (this.promisesFromId[tableId]) {
          subscriptionsLogger.logDebug("Overriding old promise for table ", tableId);
      } else {
          //>>excludeStart("debugExclude", pragmas.debugExclude);  
          Assertions.verifyNotOk(this.promisesFromId[tableId], "Promise unexpected (1)");
          Assertions.verifyNotOk(this.promiseQueuesFromId[tableId], "Promise unexpected (2)");
          //>>excludeEnd("debugExclude");
      }
      this.promisesFromId[tableId] = tableNumPromise;
      this.promiseQueuesFromId[tableId] = 0;

      tableIn.onSubmission();

      subscriptionsLogger.logDebug("Delaying subscription completion",tableIn);
      var that = this;
      this.enqueueToPromise(tableId, function(tableNumber) {

        subscriptionsLogger.logDebug("Resuming subscription completion",tableIn);
        if (! that.tableInfosFromId[tableId]) {
            //was removed
            if (that.eh) {
                that.eh.unsubscribeTable(tableNumber);
            } else {
                // the engine handler was cleared and this is no longer needed
            }
        } else {
            tableIn.onTableNumber(tableNumber);
            that.tableIdsFromNum[tableNumber] = tableId;
        }

      });

    },
    
    enqueueToPromise: function(tableId, action) {
        //>>excludeStart("debugExclude", pragmas.debugExclude);  
        Assertions.verifyOk(this.promisesFromId[tableId], "Promise not found (1)");
        if (this.promiseQueuesFromId[tableId] === 0) {
            // not covered by the assertions as a good case
        } else {
            Assertions.verifyOk(this.promiseQueuesFromId[tableId], "Promise not found (2)");
        }
        //>>excludeEnd("debugExclude");
        var promise = this.promisesFromId[tableId];
        this.promiseQueuesFromId[tableId]++;
        
        var that = this;
        var actionPhase = this.phase;
        promise["then"](function(tableNumber) {
            if (that.promisesFromId[tableId] != promise) {
                // overridden (session changed?)
                subscriptionsLogger.logDebug("Ignored old promise triggered for table ", tableId);
                return;
            }
            //>>excludeStart("debugExclude", pragmas.debugExclude);  
            Assertions.verifyOk(that.promisesFromId[tableId], "Promise not found (3)");
            Assertions.verifyOk(that.promiseQueuesFromId[tableId], "Promise not found (4)");
            //>>excludeEnd("debugExclude");
            if (that.promiseQueuesFromId[tableId] > 1) {
                that.promiseQueuesFromId[tableId]--;
            } else {
                delete(that.promisesFromId[tableId]);
                delete(that.promiseQueuesFromId[tableId]);
            }
            
            // check that session is not changed
            if (tableNumber != null && actionPhase == that.phase) {
                action(tableNumber);
            }
        },function() {
            if (that.promisesFromId[tableId] != promise) {
                // overridden (session changed?)
                subscriptionsLogger.logDebug("Ignored old promise failed for table ", tableId);
                return;
            }
            delete(that.promisesFromId[tableId]);
            delete(that.promiseQueuesFromId[tableId]);
        });
    },

    /*public*/ handleAllWaitingTables: function() {
      subscriptionsLogger.logDebug("Restoring all pending Subscriptions");
      for (var _id in this.tableInfosFromId) {
        this.passTableToEngine(this.tableInfosFromId[_id]);
      }
    },
    
    /*private*/ pauseTable: function(_table) {
    //>>excludeStart("debugExclude", pragmas.debugExclude);  
      Assertions.verifyNotOk(_table.isOff(), "Table removed");
        //OFF means removed, if it was removed it must not be here now
    //>>excludeEnd("debugExclude");
      subscriptionsLogger.logDebug("Pausing active Subscription",_table);

      delete(this.tableIdsFromNum[_table.getTableNumber()]);
      _table.onPause();
      if(_table.isSubTable()) {
        //don't remember about sub tables
        delete(this.tableInfosFromId[_table.getSubscriptionId()]);
      }
      
      
    },
    
    /*public*/ pauseAllTables: function() {
      subscriptionsLogger.logDebug("Pausing all active Subscriptions");
      
      for (var _id in this.tableInfosFromId) {
        this.pauseTable(this.tableInfosFromId[_id]);
      }
      this.tableIdsFromNum = {};
      this.phase++;
    },
    
    
/////EVENTS DISPATCHING
    
    callTableByNum: function(tableNum, method) {
        var _id = this.tableIdsFromNum[tableNum];
        if (_id) {
            // we already have a table number, but it is possible that
            // some previous task is still enqueued in the Promise
            var tableInfo = this.tableInfosFromId[_id];

            // TODO even though the initial Promise is removed in short time,
            // this check is always done; it can be relieved by saving some
            // information in the Subscription object
            if (this.promisesFromId[_id]) {
                subscriptionsLogger.logDebug("Delaying subscription action",tableInfo);
                var that = this;
                this.enqueueToPromise(_id, function(tableNumber) {
                    subscriptionsLogger.logDebug("Resuming subscription action",tableInfo);
                    //>>excludeStart("debugExclude", pragmas.debugExclude);  
                    Assertions.verifyValue(tableNumber, tableNum, "Wrong table number");
                    //>>excludeEnd("debugExclude");
                    if (that.tableIdsFromNum[tableNum] != _id) {
                        // perhaps it was removed in the meantime
                    } else {
                        var tableInfo = that.tableInfosFromId[_id];
                        if (tableInfo) {
                            method.apply(tableInfo);
                        } else {
                            // perhaps it was removed in the meantime
                        }
                    }
                });

            } else {
                // subscriptionsLogger.logDebug("Executing subscription action",tableInfo);
                if (tableInfo) {
                    method.apply(tableInfo);
                } else {
                    // perhaps it was removed in the meantime
                }
            }

        } else {
            // we are still waiting for the table number to be received;
            // unfortunately, we don't know which Promise is the one involved;
            // we can only find out all promises that are currently unfulfilled
            // (note that, since actions are sent asynchronously by the Promise,
            // we cannot ask that to the Promise itself
        	
            subscriptionsLogger.logDebug("Delaying subscription action",tableNum);
            var that = this;

            // TODO this has a quadratic effort, so it does not scale with the number
            // of subscriptions waiting to be issued when the engine is found
            var n = 0;
            for (var tableId in this.promisesFromId) {
                var sub = this.tableInfosFromId[tableId];
                if (sub) {
                    if (! sub.getTableNumber()) {
                        (function(tableId) {
                            that.enqueueToPromise(tableId, function(tableNumber) {
                                if (tableNumber == tableNum) {
                                    subscriptionsLogger.logDebug("Resuming subscription action",tableNum);
                                    if (that.tableIdsFromNum[tableNum] != tableId) {
                                        // perhaps it was removed in the meantime
                                    } else {
                                        var tableInfo = that.tableInfosFromId[tableId];
                                        if (tableInfo) {
                                            method.apply(tableInfo);
                                        } else {
                                            // perhaps it was removed in the meantime
                                        }
                                    }
                                }
                            });
                        })(tableId);
                        // an intermediate call is needed here,
                        // otherwise "tableId" would not be considered with its current value
                        // in the closure, but with its last value after all the cycles
                        // (because javascript extends its scope to the whole hosting function)
                        n++;
                    } else {
                        //>>excludeStart("debugExclude", pragmas.debugExclude);  
                        Assertions.verifyDiffValue(sub.getTableNumber(), tableNum, "Unexpected table number");
                        //>>excludeEnd("debugExclude");
                    }
                } else {
                    // perhaps it was removed in the meantime
                }
            }
            subscriptionsLogger.logDebug("Subscription action had to be delayed on multiple instances",n);
        }
    },
    
    updatePage: function(args, snap) { 
        // numero della table dell'update corrente
        var tableNum = args[0];
        
        this.callTableByNum(tableNum, function() {
            // TEMPORANEAMENTE l'indice su args corrisponde con il code del campo + 1
            // basterebbe fare due shift in questo punto per rinormalizzare tutto
            this.update(UpdateCopy(args,true),snap,false);
        });
    },
    

    onLostUpdatesEvent: function(tableNum,_item,lostUpdates) {
        this.callTableByNum(tableNum, function() {
            this.lostUpdates(_item,lostUpdates);
        });
    },
    
    onEndOfSnapshotEvent: function(tableNum,_item) {
        this.callTableByNum(tableNum, function() {
            this.endOfSnapshot(_item);
        });
    },
    
    onClearSnapshotEvent: function(tableNum,_item) {
        this.callTableByNum(tableNum, function() {
            this.clearSnapshot(_item);
        });
    },
    
    errorEvent: function(tableNum, flag, msg) {
        this.callTableByNum(tableNum, function() {
            this.serverDeny(flag, msg);
        });
    },
    
    subscriptionEvent: function(tableNum,kPos,cPos,itms,flds) {
        this.callTableByNum(tableNum, function() {
            this.onStartPush(kPos,cPos,itms,flds);
        });
    },
    
    unsubscriptionEvent: function(tableNum) {
        this.callTableByNum(tableNum, function() {
            this.onStopPush();
        });
    },
    
    doSubscriptionReconf: function(tableNum, frequency) {
        this.callTableByNum(tableNum, function() {
            this.configure(frequency);
        });
    }

    
  };
  
  export default SubscriptionsHandler;
  

  