/*
  Copyright (c) Lightstreamer Srl

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*/
import LoggerManager from "../src-log/LoggerManager";
import Setter from "../src-tool/Setter";
import Inheritance from "../src-tool/Inheritance";
import Cell from "./Cell";
import IllegalArgumentException from "../src-tool/IllegalArgumentException";

export default /*@__PURE__*/(function() {
  function getRelativeValue(value, min, unit) {
    var val = new Number(value);
    var n = (val - min) / unit;
    return Math.round(n);
  }
  
  var BLACK = "black";
  
  var gridsLogger = LoggerManager.getLoggerProxy("lightstreamer.charts");
  
  var nextId = 0;
  
  /**
   * Used by Lightstreamer to provide a ChartLine object to each call of the
   * {@link ChartListener#onNewLine} event.
   * This constructor is not supposed to be used by custom code.
   * @constructor
   *
   * @exports ChartLine
   * @class Object that describes a single line of a multi-line
   * chart. Instances of this class are automatically generated by a {@link Chart} 
   * instance based on the {@link Chart#setXAxis} and {@link Chart#addYAxis} 
   * configurations and can be customized during the {@link ChartListener#onNewLine}
   * event.
   */
  var ChartLine = function() {
    //ChartLine(key,owner,xField,yField)

    this.parent = arguments[1];
    this.yField = arguments[3];
    
    this.pointColor = BLACK;
    this.lineColor = BLACK;
    
    this.pointSize = 1;
    this.lineSize = 1;
    
    this.yMin = null; 
    this.yMax = null;
    this.yUnit = null;
    this.numYLabels = 0;
    this.labelsFormatter = null;
  
    this.xArray = [];
    this.yArray = [];
    this.labels = [];
    
    this.chartId = nextId++;

    
    gridsLogger.logDebug("New ChartLine",this);
  };
  
  ChartLine.prototype = {
      
      /**
       * @ignore
       */
      toString: function() {
        return ["[","ChartLine",this.parent,"]"].join("|");
      },
      
      /**
       * @ignore
       */
      getId: function() {
        return this.chartId;
      },
      
      /**
       * @ignore
       */
      emptyHistory: function() {
        gridsLogger.logDebug("Clearing ChartLine",this);
        
         this.yArray = [];
         this.xArray = [];
      },
      
      /**
       * @ignore
       */
      isEmpty: function() {
        return this.xArray.length <= 0;
      },
      
      /**
       * @ignore
       */
      reset: function() {
        this.emptyHistory();
        this.parent.clearLine(this);
      },
      
      /**
       * @ignore
       */
      repaint: function() {
        gridsLogger.logDebug("Repainting ChartLine",this);
      
        var xArr = this.xArray;
        var yArr = this.yArray;
        
        this.reset();
        
        //ASSERT.ensureValue(xArr.length,yArr.length);
      
        while (xArr.length > 0) {
          if ((xArr.length > 1 && xArr[1] >= this.parent.xMin) || xArr[0] >= this.parent.xMin) {
            this.addPoint(xArr[0],yArr[0]);
          }
          
          xArr.shift();
          yArr.shift();
          
        }
        gridsLogger.logDebug("ChartLine re-painted",this);
      },
      
      /**
       * @ignore
       */
      addPoint: function(xVal,yVal) {
        this.xArray.push(xVal);
        this.yArray.push(yVal);
        this.parent.drawLine(xVal,yVal,this);
      },

      /**
       * @ignore
       */
      calcYUnit: function() {
        this.yUnit = (this.yMax - this.yMin) / this.parent.screenY;
        gridsLogger.logDebug("Calculated Y unit",this,this.yUnit);
      },
      
      /**
       * @ignore
       */
      isYAxisPositioned: function() {
        return this.yMax !== null;
      },
      
      /**
       * @ignore
       */
      isPointInRange: function(yCoordinate) {
        return yCoordinate < this.yMax && yCoordinate > this.yMin;
      },
      
      /**
       * @ignore
       */
      getMin: function() {
        return this.yMin;
      },
      
      /**
       * @ignore
       */
      getMax: function() {
        return this.yMax;
      },
    
      /**
       * @ignore
       */
      paintYLabels: function() {
        this.clearLabels();
              
        var lblVal = "";
        var pos = -1;
        if (this.numYLabels <= 0) {
          return;
        }
        if (this.numYLabels > 0) {
          lblVal = this.labelsFormatter ? this.labelsFormatter(this.yMin) : this.yMin;
          pos = this.getRelativeY(this.yMin);
          this.labels[this.labels.length] = this.parent.createLabel(this.classYLabels, lblVal, pos, "Y");
        }
        if (this.numYLabels > 1) {
          lblVal = this.labelsFormatter ? this.labelsFormatter(this.yMax) : this.yMax;
          pos = this.getRelativeY(this.yMax);
          this.labels[this.labels.length] = this.parent.createLabel(this.classYLabels, lblVal, pos, "Y");
        }
        if (this.numYLabels > 2) {
          var divider = this.numYLabels - 1;
          var step = (this.yMax - this.yMin) / divider;
          var numVal = this.yMin;
          for (var w = 1; w < divider; w++) {
            numVal += step;
            lblVal = this.labelsFormatter ? this.labelsFormatter(numVal) : numVal;
            pos = this.getRelativeY(numVal);
            this.labels[this.labels.length] = this.parent.createLabel(this.classYLabels, lblVal, pos, "Y");
          }
        }
        gridsLogger.logDebug("Y labels generated",this);
      },
      
      /**
       * @ignore
       */
      getRelativeY: function(value) {
        return getRelativeValue(value, this.yMin, this.yUnit);
      },
      
      /**
       * @ignore
       */
      clearLabels: function() {
        for (var l = 0; l < this.labels.length; l++) { 
          if (this.labels[l] && Cell.isAttachedToDOM(this.labels[l])) {
             this.labels[l].parentNode.removeChild(this.labels[l]);
           }
         }  
         this.labels = [];
         gridsLogger.logDebug("Y labels cleared",this);
      },
      
      /**
       * Setter method that configures the legend for the Y axis. The legend
       * consists of a specified number of labels for the values in the Y axis.
       * The labels values are determined based on the axis limits; the labels
       * appearance is controlled by supplying a stylesheet and a formatter
       * function.
       * <BR>Note that the room for the Y axis labels on the page is not provided
       * by the library; it should be provided by specifying a chart width
       * smaller then the container element width and displaced on the right,
       * through the {@link Chart#configureArea} setting. 
       * Moreover, as the upmost and lowest labels are centered on the chart
       * area borders, a little space should be provided also over and under
       * the chart area, through the same method.
       * 
       * <p class="lifecycle"><b>Lifecycle:</b> Labels can be configured at any time.
       * If not set, no labels are displayed relative to the Y axis.
       * If set for different ChartLine instances on the same Chart
       * then more sets of labels will be printed.</p>
       * 
       * @throws {IllegalArgumentException} if labelsNum is not a valid
       * positive integer number.
       *
       * @param {Number} labelsNum the number of labels to be spread on the
       * Y axis; it should be 1 or greater.
       * @param {String} [labelsClass] the name of an existing stylesheet, to be
       * applied to the Y axis label HTML elements. The parameter is optional;
       * if missing or null, then no specific stylesheet is applied.
       * @param {LabelsFormatter} [labelsFormatter] a Function instance
       * used to format the Y axis values designated for the labels. 
       * <BR>The function will be invoked with a Number argument and should return a String.
       * If the function is not supplied, then the value will be used with no further formatting.
       */
      setYLabels: function(labelsNum, labelsClass, labelsFormatter) {
        this.numYLabels = this.checkPositiveNumber(labelsNum,true);
        this.classYLabels = labelsClass; 
        this.labelsFormatter = labelsFormatter || null;
        
        gridsLogger.logDebug("Y labels now configured",this);
        
        if (this.yUnit != null && this.parent && this.parent.painter) {
          //l'asse Y � gi� configurato, disegno le labels
          this.paintYLabels(); //screenY e yMax (yUnit) - chartArea.parentNode
        }
    
        
      },
      
      /**
       * Setter method that sets the style to be applied to the points
       * drawn on the chart area. Colors of the points,
       * and lines can be customized using valid CSS colors while size is specified
       * in pixels. 
       * 
       * @throws {IllegalArgumentException} if pointSize or lineSize are not
       * valid positive integer numbers.
       *
       * @param {String} [pointColor=black]the color use to draw the points on the chart.
       * A point is drawn per each new value in the model. Any valid CSS color can
       * be used. By default "black" is used.
       * @param {String} [lineColor=black] the color use to draw the lines on the chart.
       * A line is to connect two consecutive points for the same line. 
       * Any valid CSS color can be used. By default "black" is used.
       * @param {Number} [pointSize=1] the size in pixel of the drawn points.
       * By default 1 is used.
       * @param {Number} [lineSize=1] the size in pixel of the drawn lines.
       * By default 1 is used.
       */
      setStyle: function(pointColor,lineColor,pointSize,lineSize) {
        this.pointColor = pointColor;
        this.lineColor = lineColor;
        
        this.pointSize = this.checkPositiveNumber(pointSize);
        this.lineSize = this.checkPositiveNumber(lineSize);
        
        gridsLogger.logDebug("Line style configured",this);
      },
      
      /**
       * Operation method that sets or changes the limits for the visible part
       * of the Y axis of the chart (that is, the minimum and maximum Y-coordinates
       * shown in the chart for this line).
       * When these limits are changed a full repaint of the line is performed.
       *
       * <p class="lifecycle"><b>Lifecycle:</b> The Y axis limits can be set at any time.</p>
       * 
       * @throws {IllegalArgumentException} if the min parameter is greater 
       * than the max one.
       *
       * @param {Number} min lower limit for the visible part of the Y axis.
       * @param {Number} max higher limit for the visible part of the Y axis.
       */
      positionYAxis: function(min, max) {
        this.yMax = Number(max);
        this.yMin = Number(min);

        
        if (isNaN(this.yMax) || isNaN(this.yMin)) {
          throw new IllegalArgumentException("Min and max must be numbers");
        } if (this.yMin > this.yMax) {
          throw new IllegalArgumentException("The maximum value must be greater than the minimum value");
        }
        
        if (this.parent && this.parent.screenY != null && this.parent.painter) {
          this.calcYUnit();
          this.paintYLabels(); //sreenY - yMax - chartArea.parentNode
          if (!this.isEmpty()) {
            this.repaint();
          } 
        }
    
        gridsLogger.logDebug("Y axis is now positioned",this);
      },
      
      /**  
       * Inquiry method that retrieves the field in the Chart internal model
       * representing the Y axis to which this ChartLine pertains.
       * 
       * @return {Number} the field representing the Y axis.
       * 
       * @see Chart#addYAxis
       */
      getYField: function() {
        return this.yField;
      }
    
  };

  ChartLine.prototype["setYLabels"] = ChartLine.prototype.setYLabels;
  ChartLine.prototype["setStyle"] = ChartLine.prototype.setStyle;
  ChartLine.prototype["positionYAxis"] = ChartLine.prototype.positionYAxis;
  ChartLine.prototype["getYField"] = ChartLine.prototype.getYField;

  Inheritance(ChartLine,Setter,"O");
  return ChartLine;
})();
  
